
"""üß† EJERCICIO 1 ‚Äî Elegir la estructura correcta (y justificarla)

Tienes una lista de n√∫meros enteros que representa IDs de usuarios que han realizado una acci√≥n:

ids = [4, 7, 2, 7, 4, 9, 2, 4, 10, 7, 3, 2, 9, 9, 4]


Quiero que hagas tres cosas, pero no de cualquier manera:

‚úÖ Parte A ‚Äî Usuarios √∫nicos

Obt√©n los IDs sin duplicados.

Pero quiero:

la forma m√°s clara

la m√°s eficiente

y que puedas explicar por qu√© esa estructura es la correcta

‚úÖ Parte B ‚Äî Conteo de ocurrencias

Calcula cu√°ntas veces aparece cada ID.

Requisitos:

resultado en un dict

sin usar list.count() en un bucle (eso ser√≠a O(n¬≤))

‚úÖ Parte C ‚Äî IDs que aparecen m√°s de una vez

Obt√©n un conjunto (set) con los IDs que aparecen 2 o m√°s veces.

Pero:

no recorras la lista m√°s veces de las necesarias

aprovecha lo que ya calculaste antes si tiene sentido"""

from collections import Counter

ids = [4, 7, 2, 7, 4, 9, 2, 4, 10, 7, 3, 2, 9, 9, 4]
print(ids)

# Parte A
ids_sin_duplicados = set(ids)
print(ids_sin_duplicados)

# Parte B

conteo = Counter(ids) # Se utiliza Counter que est√° importado de la librer√≠a "collections" que hemos cargado al principio.
print(conteo)

"""La forma que se utilizar√≠a sin usar la librer√≠a collectins ser√≠a:
conteo = {}

for n in ids:
    conteo[n] = conteo.get(n, 0) + 1
    

"""
#parte C
repetidos = {n for n, count in conteo.items() if count >= 2}
print(repetidos)

"""
üî• EJERCICIO 2 ‚Äî Primer elemento repetido (en O(n))

Te doy una lista:

ids = [5, 3, 8, 2, 9, 1, 3, 7, 8]

Objetivo:

Encontrar el primer ID que se repite
(en este caso ser√≠a 3).

Reglas:

‚ùå no usar count

‚ùå no usar doble bucle

‚úÖ solo una pasada por la lista

‚úÖ usa la estructura adecuada

    """

ids = [5, 3, 8, 2, 9, 1, 3, 7, 8]
def primer_repetido(ids):
    vistos = set()

    for x in ids:
        if x in vistos:
            return x
        vistos.add(x)

    return None
print(primer_repetido(ids))
        
"""
üî• EJERCICIO 3 ‚Äî Ventana deslizante (sliding window)

Esto es pensamiento algor√≠tmico intermedio y se usa much√≠simo.

Problema

Tienes una lista de n√∫meros:

nums = [2, 1, 5, 1, 3, 2, 6]
k = 3


Queremos encontrar la suma m√°xima de cualquier sublista contigua de tama√±o k.

Ejemplos de ventanas:

[2, 1, 5] ‚Üí suma 8

[1, 5, 1] ‚Üí suma 7

[5, 1, 3] ‚Üí suma 9

[1, 3, 2] ‚Üí suma 6

[3, 2, 6] ‚Üí suma 11 ‚úÖ

Resultado: 11

‚ùå Prohibido

recalcular la suma completa en cada ventana (eso ser√≠a O(n¬∑k))

‚úÖ Objetivo

una sola pasada ‚Üí O(n)

reutilizar el c√°lculo anterior  
    """

nums = [2, 1, 5, 1, 3, 2, 6]
k = 3

window_sum = sum(nums[:k])
max_sum = window_sum

for i in range(k, len(nums)):
    window_sum = window_sum + nums[i] - nums[i - k]
    if window_sum > max_sum:
        max_sum = window_sum

print(max_sum)

""" 
üî• Mini-reto final de este ejercicio

Completa esta idea:

guarda tambi√©n el √≠ndice cuando haya nuevo m√°ximo

al final devuelve la sublista

Estructura:

window_sum = sum(nums[:k])
max_sum = window_sum
end_index = k - 1

for i in range(k, len(nums)):
    window_sum = window_sum + nums[i] - nums[i - k]
    if window_sum > max_sum:
        max_sum = window_sum
        end_index = i

sublista = nums[end_index - k + 1 : end_index + 1]


Intenta escribirlo t√∫ completo, ejec√∫talo, y dime qu√© te devuelve.
Con esto ya cierras el concepto de sliding window como un pro. üí™üî•
"""

nums = [2, 1, 5, 1, 3, 2, 6]
k = 3

# inicializamos la primera ventana
window_sum = sum(nums[:k])
window_max = window_sum
end_index = k - 1  # √≠ndice final de la ventana actual con m√°ximo

# recorremos el resto de la lista
for i in range(k, len(nums)):
    window_sum = window_sum + nums[i] - nums[i - k]  # update de la ventana
    if window_sum > window_max:
        window_max = window_sum
        end_index = i  # actualizamos d√≥nde termina la ventana m√°xima

# obtenemos la sublista del m√°ximo
sublista = nums[end_index - k + 1 : end_index + 1]
print(f"La sublista con suma m√°xima es: {sublista} y su suma es: {window_max}")

"""üî• EJERCICIO 3 ‚Äî Sliding Window Avanzado

Tenemos una lista de temperaturas diarias (en ¬∫C) de una semana:

temperaturas = [15, 18, 21, 20, 19, 23, 22, 24]
k = 4

Objetivo:

Encuentra la sublista de k d√≠as consecutivos con la temperatura promedio m√°s alta.

Devuelve la sublista y el promedio.

Hazlo en una sola pasada, sin recalcular la suma completa cada vez.

Reglas:

‚ùå No uses sum() dentro del bucle.

‚úÖ Usa sliding window (actualiza suma/estado cada vez).

‚úÖ Devuelve sublista y promedio m√°ximo."""


temperaturas = [15, 18, 21, 20, 19, 23, 22, 24]
k = 4

window_sum = sum(temperaturas[:k])
window_max = window_sum
end_index = k - 1

for i in range(k, len(temperaturas)):
    window_sum = window_sum + temperaturas[i] - temperaturas[i - k]
    if window_sum > window_max:
        window_max = window_sum
        end_index = i
promedio = window_max/k
sublista = temperaturas[end_index - k + 1: end_index + 1]
print(f"La sublista es: {sublista} y el promedio es: {promedio}")

"""üî• EJERCICIO 4 ‚Äî Sliding Window Variable + Condici√≥n

Lista de ventas diarias (unidades vendidas):

ventas = [5, 2, 6, 1, 3, 2, 8, 4, 5, 7]

Objetivo:

Encuentra la sublista contigua m√°s larga cuya suma no supere 15 unidades.

Devuelve la sublista y su suma.

Hazlo en una sola pasada y sin recalcular la suma completa cada vez.

Pistas:

Aqu√≠ la ventana no tiene tama√±o fijo.

Necesitas mantener dos √≠ndices: inicio y fin de la ventana actual.

Cada vez que la suma exceda 15:

mueve el inicio hacia la derecha hasta que la suma vuelva a estar ‚â§ 15.

Si la suma est√° dentro del l√≠mite y la ventana es m√°s larga que la m√°xima conocida ‚Üí actualiza resultado."""

ventas = [5, 2, 6, 1, 3, 2, 8, 4, 5, 7]
i = 0
mayor_sublista = []
suma_maxima = 0
suma_actual = 0

# En Python, es m√°s limpio usar un for para el puntero derecho (j)
# 'j' representa el final de nuestra ventana actual
for j in range(len(ventas)):
    # 1. Expandimos la ventana a√±adiendo el nuevo elemento
    suma_actual += ventas[j]
    
    # 2. Mientras la suma sea mayor a 15, achicamos por la izquierda (i)
    # Esto asegura que la ventana siempre sea v√°lida antes de medirla
    while suma_actual > 15 and i <= j:
        suma_actual -= ventas[i]
        i += 1
    
    # 3. Ahora que la ventana es v√°lida (suma <= 15), medimos
    sublista_actual = ventas[i : j + 1] # j+1 porque el slice es exclusivo
    
    if len(sublista_actual) > len(mayor_sublista):
        mayor_sublista = sublista_actual
        suma_maxima = suma_actual

print(f"La sublista m√°s larga es: {mayor_sublista}")
print(f"Longitud: {len(mayor_sublista)} | Suma: {suma_maxima}")

# Tip Pro: Usar 'suma_actual += ...' y 'suma_actual -= ...' es mucho m√°s
# eficiente que hacer 'sum(ventas[i:j])' en cada vuelta del bucle.
